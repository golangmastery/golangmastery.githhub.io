{"pageProps":{"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Every process, that is executed, has the standard output, input and error output. The Go standard library provides the way to read and write to these.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"This recipe will walk through the approaches on how to read the output and write to the input of the child process.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"create-the-main_read_outputgo-file-with-the-following-content\",\n      children: \"Create the main_read_output.go file with the following content:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"       package main\\n\\n       import (\\n         \\\"fmt\\\"\\n         \\\"os/exec\\\"\\n         \\\"runtime\\\"\\n       )\\n\\n       func main() {\\n\\n         var cmd string\\n\\n         if runtime.GOOS == \\\"windows\\\" {\\n           cmd = \\\"dir\\\"\\n         } else {\\n           cmd = \\\"ls\\\"\\n         }\\n\\n         proc := exec.Command(cmd)\\n\\n         // Output will run the process\\n         // terminates and returns the standard\\n         // output in a byte slice.\\n         buff, err := proc.Output()\\n\\n         if err != nil {\\n           panic(err)\\n         }\\n\\n         // The output of child\\n         // process in form\\n         // of byte slice\\n         // printed as string\\n         fmt.Println(string(buff))\\n\\n       }\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"output\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Biradars-MacBook-Air-4:golang-daily sangam$ go run main.go\\nbinary\\nmain\\nmain.go\\nrun.go\\nstart.go\\ntest\\nutil\\n\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"create-the-main_read_stdoutgo-file-with-the-following-content\",\n      children: \"Create the main_read_stdout.go file with the following content:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        package main\\n\\n        import (\\n          \\\"bytes\\\"\\n          \\\"fmt\\\"\\n          \\\"os/exec\\\"\\n          \\\"runtime\\\"\\n        )\\n\\n        func main() {\\n\\n          var cmd string\\n\\n          if runtime.GOOS == \\\"windows\\\" {\\n            cmd = \\\"dir\\\"\\n          } else {\\n            cmd = \\\"ls\\\"\\n          }\\n\\n          proc := exec.Command(cmd)\\n\\n          buf := bytes.NewBuffer([]byte{})\\n\\n          // The buffer which implements\\n          // io.Writer interface is assigned to\\n          // Stdout of the process\\n          proc.Stdout = buf\\n\\n          // To avoid race conditions\\n          // in this example. We wait till\\n          // the process exit.\\n          proc.Run()\\n\\n          // The process writes the output to\\n          // to buffer and we use the bytes\\n          // to print the output.\\n          fmt.Println(string(buf.Bytes()))\\n\\n        }\\n\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"output\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Biradars-MacBook-Air-4:golang-daily sangam$ go run main.go\\nbinary\\nmain\\nmain.go\\nrun.go\\nstart.go\\ntest\\n\\n\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"create-the-main_read_readgo-file-with-the-following-content\",\n      children: \"Create the main_read_read.go file with the following content:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        package main\\n\\n        import (\\n          \\\"bufio\\\"\\n          \\\"context\\\"\\n          \\\"fmt\\\"\\n          \\\"os/exec\\\"\\n          \\\"time\\\"\\n        )\\n\\n        func main() {\\n          cmd := \\\"ping\\\"\\n          timeout := 2 * time.Second\\n\\n          // The command line tool\\n          // \\\"ping\\\" is executed for\\n          // 2 seconds\\n          ctx, _ := context.WithTimeout(context.TODO(), timeout)\\n          proc := exec.CommandContext(ctx, cmd, \\\"example.com\\\")\\n\\n          // The process output is obtained\\n          // in form of io.ReadCloser. The underlying\\n          // implementation use the os.Pipe\\n          stdout, _ := proc.StdoutPipe()\\n          defer stdout.Close()\\n\\n          // Start the process\\n          proc.Start()\\n\\n          // For more comfortable reading the\\n          // bufio.Scanner is used.\\n          // The read call is blocking.\\n          s := bufio.NewScanner(stdout)\\n          for s.Scan() {\\n            fmt.Println(s.Text())\\n          }\\n        }\\n\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"output\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Biradars-MacBook-Air-4:golang-daily sangam$ go run main.go\\nPING example.com (93.184.216.34): 56 data bytes\\n64 bytes from 93.184.216.34: icmp_seq=0 ttl=51 time=411.571 ms\\n64 bytes from 93.184.216.34: icmp_seq=1 ttl=51 time=217.384 ms\\nBiradars-MacBook-Air-4:golang-daily sangam$ \\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"create-the-samplego-file-with-the-following-content\",\n      children: \"Create the sample.go file with the following content:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        package main\\n\\n        import (\\n          \\\"bufio\\\"\\n          \\\"fmt\\\"\\n          \\\"os\\\"\\n        )\\n\\n        func main() {\\n          sc := bufio.NewScanner(os.Stdin)\\n\\n          for sc.Scan() {\\n            fmt.Println(sc.Text())\\n          }\\n        }\\n\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"create-the-maingo-file-with-the-following-content\",\n      children: \"Create the main.go file with the following content:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        package main\\n\\n        import (\\n          \\\"bufio\\\"\\n          \\\"fmt\\\"\\n          \\\"io\\\"\\n          \\\"os/exec\\\"\\n          \\\"time\\\"\\n        )\\n\\n        func main() {\\n          cmd := []string{\\\"go\\\", \\\"run\\\", \\\"sample.go\\\"}\\n\\n          // The command line tool\\n          // \\\"ping\\\" is executed for\\n          // 2 seconds\\n          proc := exec.Command(cmd[0], cmd[1], cmd[2])\\n\\n          // The process input is obtained\\n          // in form of io.WriteCloser. The underlying\\n          // implementation use the os.Pipe\\n          stdin, _ := proc.StdinPipe()\\n          defer stdin.Close()\\n\\n          // For debugging purposes we watch the\\n          // output of the executed process\\n          stdout, _ := proc.StdoutPipe()\\n          defer stdout.Close()\\n\\n          go func() {\\n            s := bufio.NewScanner(stdout)\\n            for s.Scan() {\\n              fmt.Println(\\\"Program says:\\\" + s.Text())\\n            }\\n          }()\\n\\n          // Start the process\\n          proc.Start()\\n\\n          // Now the following lines\\n          // are written to child\\n          // process standard input\\n          fmt.Println(\\\"Writing input\\\")\\n          io.WriteString(stdin, \\\"Hello\\\\n\\\")\\n          io.WriteString(stdin, \\\"Golang\\\\n\\\")\\n          io.WriteString(stdin, \\\"is awesome\\\\n\\\")\\n\\n          time.Sleep(time.Second * 2)\\n\\n          proc.Process.Kill()\\n\\n        }\\n        \\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"output\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Biradars-MacBook-Air-4:golang-daily sangam$ go run main.go\\nWriting input\\nProgram says:Hello\\nProgram says:Golang\\nProgram says:is awesome\\nBiradars-MacBook-Air-4:golang-daily sangam$ \\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"how-it-works\",\n      children: \"How it worksâ€¦\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The Cmd structure of the os/exec package provides the functions to access the output/input of the process. There are a few approaches to read the output of the process.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"One of the simplest ways to read the process output is to use the Output or CombinedOutput method of the Cmd structure (gets Stderr and Stdout). While calling this function, the program synchronously waits till the child process terminates and then returns the output to a byte buffer.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Besides the Output and OutputCombined methods, the Cmd structure provides the Stdout property, where the io.Writer could be assigned. The assigned writer then serves as a destination for the process output. It could be a file, byte buffer or any type implementing the io.Writer interface.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The last approach to read the process output is to get the io.Reader from the Cmd structure by calling the StdoutPipe method. The StdoutPipe method creates the pipe between the Stdout, where the process writes the output, and provides Reader which works as the interface for the program to read the process output. This way the output of the process is piped to the retrieved io.Reader .\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Writing to a process stdin works the same way. Of all the options, the one with io.Writer will be demonstrated.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"As could be seen, there are a few ways to read and write from the child process. The use of stderr and stdin is almost the same as described in steps 6-7. Finally, the approach of how to access the input/output could be divided this way:\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Synchronous (wait until the process ends and get the bytes): The Output and CombinedOutput methods of Cmd are used.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"IO: The output or input are provided in the form of io.Writer/Reader. The XXXPipe and StdXXX properties are the right ones for this approach.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The IO type is more flexible and could also be used asynchronously.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontMatter":{"title":"Reading writing from the child process","description":"Learning Go programming","order":53},"courseSlug":"quick-start-with-golang","modules":[{"slug":"01-introduction-to-go","title":"Introduction to Go","description":"Learn about the Go programming language, its history, features, and why it's becoming increasingly popular for modern software development.","order":1},{"slug":"02-lets-start-with-first-hello-world-program","title":"Lets Start With First Hello world Program","description":"Learning Go programming","order":2},{"slug":"03-numeral-systems---decimal","title":"Numeral Systems - Decimal","description":"Learning Go programming","order":3},{"slug":"04-numeral-systems---binary","title":"Numeral Systems - Binary","description":"Learning Go programming","order":4},{"slug":"05-numeral-systems---hexadecimal","title":"Numeral Systems - Hexadecimal","description":"Learning Go programming","order":5},{"slug":"06-numeral-systems---loop","title":"Numeral Systems - Loop","description":"Learning Go programming","order":6},{"slug":"07-numeral-systems-utf-8","title":"Numeral Systems UTF-8","description":"Learning Go programming","order":7},{"slug":"08-short-variable-declarations","title":"Short variable declarations","description":"Learning Go programming","order":8},{"slug":"09-variable-with-zero-value","title":"Variable with zero value","description":"Learning Go programming","order":9},{"slug":"10-deep-drive-on-variables","title":"Deep Drive on Variables","description":"Learning Go programming","order":10},{"slug":"11-hello-world-in-go","title":"Hello World in Go","description":"Write and understand your first Go program","order":11},{"slug":"12-deep-drive-on-constants","title":"Deep Drive On Constants","description":"Learning Go programming","order":12},{"slug":"13-loop-init-condition-post","title":"Loop  Init, Condition, Post","description":"Learning Go programming","order":13},{"slug":"14-loop---nested-loops","title":"Loop - Nested Loops","description":"Learning Go programming","order":14},{"slug":"15-loop---for-statement","title":"Loop - For Statement","description":"Learning Go programming","order":15},{"slug":"16-loop---break-continue","title":"Loop - Break & Continue","description":"Learning Go programming","order":16},{"slug":"17-generate-random-number-with-mathcryptorand-in-go","title":"Generate Random number with math/crypto/rand in Go","description":"Learning Go programming","order":17},{"slug":"18-loop---printing-ascii","title":"Loop - Printing ASCII","description":"Learning Go programming","order":18},{"slug":"19-conditional---if-statement","title":"Conditional - If Statement","description":"Learning Go programming","order":19},{"slug":"20-conditional---if-else-if-else","title":"Conditional - If, Else if, Else","description":"Learning Go programming","order":20},{"slug":"21-loop-conditional-modulus","title":"Loop, Conditional, Modulus","description":"Learning Go programming","order":21},{"slug":"22-variables-and-data-types","title":"Variables and Data Types","description":"Learn about variables, data types, and how to work with them in Go","order":22},{"slug":"23-conditional---switch-statement","title":"Conditional - Switch Statement","description":"Learning Go programming","order":23},{"slug":"24-conditional---switch-statement-documentation","title":"Conditional - Switch Statement Documentation","description":"Learning Go programming","order":24},{"slug":"25-conditional-logic-operators","title":"Conditional Logic Operators","description":"Learning Go programming","order":25},{"slug":"26-string-type","title":"String Type","description":"Learning Go programming","order":26},{"slug":"27-bool-type","title":"Bool Type","description":"Learning Go programming","order":27},{"slug":"28-structs","title":"Structs","description":"Learning Go programming","order":28},{"slug":"29-struct-literal","title":"Struct Literal","description":"Learning Go programming","order":29},{"slug":"30-pointer-to-struct","title":"Pointer to struct","description":"Learning Go programming","order":30},{"slug":"31-conversion-not-casting","title":"Conversion, Not Casting","description":"Learning Go programming","order":31},{"slug":"32-creating-your-own-type","title":"Creating Your Own Type","description":"Learning Go programming","order":32},{"slug":"33-control-structures","title":"Control Structures","description":"Learn about conditional statements and loops in Go","order":33},{"slug":"34-defer","title":"Defer","description":"Learning Go programming","order":34},{"slug":"35-stacking-defers","title":"Stacking defers","description":"Learning Go programming","order":35},{"slug":"36-pointer","title":"Pointer","description":"Learning Go programming","order":36},{"slug":"37-prefix-suffix","title":"Prefix Suffix","description":"Learning Go programming","order":37},{"slug":"38-conversion-between-array-and-slice","title":"Conversion between array and slice","description":"Learning Go programming","order":38},{"slug":"39-methods","title":"methods","description":"Learning Go programming","order":39},{"slug":"40-variadic-function","title":"variadic function","description":"Learning Go programming","order":40},{"slug":"41-init-function","title":"init Function","description":"Learning Go programming","order":41},{"slug":"42-command-line-arguments-and-file-io","title":"Command Line Arguments and File I/O","description":"Learning Go programming","order":42},{"slug":"43-what-is-interface-","title":"what is interface ?","description":"Learning Go programming","order":43},{"slug":"44-functions-in-go","title":"Functions in Go","description":"Learn how to create and use functions in Go, including function parameters, return values, and closures","order":44},{"slug":"45-retrieving-the-golang-version","title":"Retrieving the Golang version","description":"Learning Go programming","order":45},{"slug":"46-accessing-program-arguments","title":"accessing program arguments","description":"Learning Go programming","order":46},{"slug":"47-creating-a-program-interface-with-the-flag-package","title":"Creating a program interface with the flag package","description":"Learning Go programming","order":47},{"slug":"48-retrieving-the-current-working-directory","title":"Retrieving the current working directory","description":"Learning Go programming","order":48},{"slug":"49-getting-the-current-process-pid","title":"Getting the current process PID","description":"Learning Go programming","order":49},{"slug":"50-handling-operating-system-signals","title":"Handling operating system signals","description":"Learning Go programming","order":50},{"slug":"51-calling-an-external-proces","title":"calling an external proces","description":"Learning Go programming","order":51},{"slug":"52-retrieving-child-process-information","title":"Retrieving child process information","description":"Learning Go programming","order":52},{"slug":"53-reading-writing-from-the-child-process","title":"Reading writing from the child process","description":"Learning Go programming","order":53},{"slug":"54-shutting-down-the-application-gracefully","title":"Shutting down the application gracefully","description":"Learning Go programming","order":54},{"slug":"55-file-configuration-with-functional-options","title":"file configuration with functional options","description":"Learning Go programming","order":55},{"slug":"56-finding-the-substring-in-a-string","title":"Finding the substring in a string","description":"Learning Go programming","order":56},{"slug":"57-breaking-the-string-into-words","title":"breaking the string into words","description":"Learning Go programming","order":57},{"slug":"58-joining-the-string-slice-with-a-separator","title":"Joining the string slice with a separator","description":"Learning Go programming","order":58},{"slug":"59-concatenating-a-string-with-writer","title":"Concatenating a string with writer","description":"Learning Go programming","order":59},{"slug":"60-aligning-text-with-tabwriter","title":"Aligning text with tabwriter","description":"Learning Go programming","order":60},{"slug":"61-replacing-part-of-the-string","title":"Replacing part of the string","description":"Learning Go programming","order":61},{"slug":"62-finding-the-substring-in-text-by-the-regex-pattern","title":"finding the substring in text by the regex pattern","description":"Learning Go programming","order":62},{"slug":"63-controlling-case","title":"controlling case","description":"Learning Go programming","order":63},{"slug":"64-parsing-comma-separated-data","title":"parsing comma-separated data","description":"Learning Go programming","order":64},{"slug":"65-managing-whitespace-in-a-string","title":"managing whitespace in a string","description":"Learning Go programming","order":65},{"slug":"66-indenting-a-text-document","title":"indenting a text document","description":"Learning Go programming","order":66},{"slug":"67-converting-strings-to-numbers","title":"converting strings to numbers","description":"Learning Go programming","order":67},{"slug":"68-comparing-floating-point-numbers","title":"comparing floating-point numbers","description":"Learning Go programming","order":68},{"slug":"69-rounding-floating-point-numbers","title":"rounding floating-point numbers","description":"Learning Go programming","order":69},{"slug":"70-floating-point-arithmetics","title":"floating-point arithmetics","description":"Learning Go programming","order":70},{"slug":"71-formatting-numbers","title":"formatting numbers","description":"Learning Go programming","order":71},{"slug":"72-converting-between-binary-octal-decimal-and-hexadecimal","title":"Converting between binary, octal, decimal, and hexadecimal","description":"Learning Go programming","order":72},{"slug":"73-formatting-with-the-correct-plurals","title":"formatting with the correct plurals","description":"Learning Go programming","order":73},{"slug":"74-generating-random-numbers","title":"generating random numbers","description":"Learning Go programming","order":74},{"slug":"75-operating-complex-numbers","title":"operating complex numbers","description":"Learning Go programming","order":75},{"slug":"76-converting-between-degrees-and-radians","title":"converting between degrees and radians","description":"Learning Go programming","order":76},{"slug":"77-taking-logarithms","title":"taking logarithms","description":"Learning Go programming","order":77},{"slug":"78-generating-checksums","title":"generating checksums","description":"Learning Go programming","order":78},{"slug":"79-reading-standard-input","title":"reading standard input","description":"Learning Go programming","order":79},{"slug":"80-writing-standard-output-and-error","title":"Writing standard output and error","description":"Learning Go programming","order":80},{"slug":"81-opening-a-file-by-name","title":"opening a file by name","description":"Learning Go programming","order":81},{"slug":"82-reading-the-file-into-a-string","title":"reading the file into a string","description":"Learning Go programming","order":82},{"slug":"83-reading-writing-a-different-charset","title":"Reading writing a different charset","description":"Learning Go programming","order":83},{"slug":"84-seeking-a-position-within-a-file","title":"Seeking a position within a file","description":"Learning Go programming","order":84},{"slug":"85-reading-and-writing-binary-data","title":"reading and writing binary data","description":"Learning Go programming","order":85},{"slug":"86-writing-to-multiple-writers-at-once","title":"writing to multiple writers at once","description":"Learning Go programming","order":86},{"slug":"87-piping-between-writer-and-reader","title":"piping between writer and reader","description":"Learning Go programming","order":87},{"slug":"88-serializing-objects-to-binary-format","title":"serializing objects to binary format","description":"Learning Go programming","order":88},{"slug":"89-reading-and-writing-zip-files","title":"reading and writing ZIP files","description":"Learning Go programming","order":89},{"slug":"90-parsing-a-large-xml-file-effectively","title":"Parsing a large XML file effectively","description":"Learning Go programming","order":90},{"slug":"91-extracting-data-from-an-incomplete-json-array","title":"extracting data from an incomplete JSON array","description":"Learning Go programming","order":91},{"slug":"92-getting-file-information","title":"getting file information","description":"Learning Go programming","order":92},{"slug":"93-creating-temporary-files","title":"creating temporary files","description":"Learning Go programming","order":93},{"slug":"94-writing-the-file","title":"writing the file","description":"Learning Go programming","order":94},{"slug":"95-writing-the-file-from-multiple-goroutines","title":"writing the file from multiple goroutines","description":"Learning Go programming","order":95},{"slug":"96-listing-a-directory","title":"listing a directory","description":"Learning Go programming","order":96},{"slug":"97-changing-file-permissions","title":"Changing file permissions","description":"Learning Go programming","order":97},{"slug":"98-creating-files-and-directories","title":"Creating files and directories","description":"Learning Go programming","order":98},{"slug":"99-filtering-file-listings","title":"Filtering file listings","description":"Learning Go programming","order":99},{"slug":"100-comparing-two-files","title":"comparing two files","description":"Learning Go programming","order":100},{"slug":"101-resolving-the-user-home-directory","title":"Resolving the user home directory","description":"Learning Go programming","order":101},{"slug":"example-code-highlighting","title":"Code Highlighting Examples","description":"Learn how to use various code syntax highlighting features in Go examples","order":101},{"slug":"custom-code-highlighting","title":"Advanced Code Highlighting Features","description":"Learn how to use the enhanced code block features like line highlighting, titles, and more.","order":102}],"currentModule":{"slug":"53-reading-writing-from-the-child-process","title":"Reading writing from the child process","description":"Learning Go programming","order":53}},"__N_SSG":true}